class Api::V1::QuestionsController < Api::ApplicationController
    # this controller is generated by rails g controller api/v1/questions --no-assets --no-helper --skip-template-engine
    # also remember to change the parent class => Api::ApplicationController

    before_action :authenticate_user!, except: [:index, :show]

    rescue_from ActiveRecord::RecordNotFound, with: :record_not_found

    rescue_from ActiveRecord::RecordInvalid, with: :record_invalid

    def index
        questions = Question.order(created_at: :desc)
        # render(json: questions)
        #If the serializer name does not match the model (like questions_serializer matches question.rb)
        #then we need to specify in the specific controller actions which serializer to use
        #with the methos "each_serializer"
        render(json: questions, each_serializer: QuestionCollectionSerializer)
        # we will provide 'each_serializer' named argument to the option hash of the render method that tells which serializer to use with each instance
    end

    #=====POSTMAN index====>
    #name: questions#index
    #request: GET -> http://localhost:3000/api/v1/questions
    #================>

    def show
        question = Question.find(params[:id])
        render(json: question)
        # because question model matches with question serializer, we don't need to 
        #specify which serializer to use like we do above with index and QuestionCollectionSerializer
        # render(json: question, each_serializer: QuestionSerializer)
    end

    #=====POSTMAN show====>
    #name: questions#show
    #request: GET -> http://localhost:3000/api/v1/questions/:id
    #Params: key: id, value: 326 (or any value that exists in your database)
    #================>

    def create
        question = Question.new(question_params)
        # question.user = User.first #hard code user for now
        question.user = current_user
        # if question.save
        #     render json: { id: question.id }
        # else
        #     render(
        #         json: {errors: question.errors.messages },
        #         status: 422 #unprocessable entity HTTP status code
        #     )
        # end
        question.save!
        render json: {id: question.id}
    end

    #=====POSTMAN create====>
    #name: questions#create
    #request: POST -> http://localhost:3000/api/v1/questions
    #Headers: key: Content-Type, value: application/json
    #Body: raw, JSON
    #Example question: {"question": {"title":"New unique question!", "body":"This is a newly created question" }}
    #**Remember, this will only work if a user is hard coded, or if session has been created
    #================>

    def update
        question = Question.find(params[:id])
        if question.update(question_params)
            render json: {id: question.id }
        else
            render(
                json: { errors: question.errors.messages },
                status: 422
            )
        end
    end
    #=====POSTMAN update====>
    #name: questions#update
    #request: PATCH -> http://localhost:3000/api/v1/questions/:id
    #Params: key: id, value: 326 (or any value that exists in your database)
    #Headers: key: Content-Type, value: application/json
    #Body: raw, JSON
    #Example question update: {"title": "Title is now updated", "body": "Body is also updated"}
    #**Remember, this will only work if a user is hard coded, or if session has been created
    #================>

    def destroy
        question = Question.find(params[:id])
        if question.destroy
            # head :ok
            render(
                json: { status: 200 }
            )
        else
            # head :bad_request
            render( json: {status: 500})
        end
    end
    #=====POSTMAN destroy====>
    #name: questions#destroy
    #request: DELETE -> http://localhost:3000/api/v1/questions/:id
    #Params: key: id, value: 326 (or any value that exists in your database)
    #**Remember, this will only work if a user is hard coded, or if session has been created
    #================>

    private

    def question_params
        params.require(:question).permit(:title, :body, :tag_names)
    end

    protected

    #protected is like private except that it prevents
    #decendent classes from using the protected methods

    def record_not_found(error)
        render(
            status: 404, #alias :not_found
            json: {
                errors: [
                    {
                        type: error.class.to_s,
                        message: error.message
                    }
                ]
            }
        )
    end

    def record_invalid(error)
        invalid_record = error.record
        errors = invalid_record.errors.map do |errorObject|
            {
                type: invalid_record.class.to_s,
                field: errorObject.attribute,
                message: errorObject.options[:message]
            }
        end
        render(
            json: { status: 422, errors: errors },
            status: 422 #alias :unprocessable_entity
        )
    end

    # def record_invalid(error)
    #     #Our object should look something like this:
    #     # json: {
    #     #     errors: [
    #     #         {
    #     #             type: "ActiveRecord:InvalidRecord",
    #     #             record_type: "Question",
    #     #             field: "body",
    #     #             message: "..."
    #     #         }
    #     #     ]
    #     # }

    #     invalid_record = error.record
    #     errors = invalid_record.errors.map do |field, message|
    #         {
    #             type: invalid_record.class.to_s,
    #             field: field,
    #             message: message
    #         }
    #     end
    #     render(
    #         json: { status: 422, errors: errors },
    #         status: 422 #alias :unprocessable_entity
    #     )
    # end


end







